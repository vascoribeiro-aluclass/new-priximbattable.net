<!DOCTYPE html>
<html lang="en">

<head>
    <!-- <title></title> -->
    <!-- <meta charset="utf-8"> -->
       <!-- <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"> -->
    <link href="css/headerScreen.css" rel="stylesheet">
    <style>
        body {
            margin: 0px;
            overflow: hidden;
        }
    </style>
</head>

<body>

    <script src="js/headerScreen.js"></script>
    <script src="js/threejs/three.js">
        import * as THREE from 'https://cdn.skypack.dev/three@0.133.0'
        import { RGBLoader } from 'https://cdn.skypack.dev/three@0.133.0/examples/jsm/loaders/RGBLoader.js'
        import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.133.0/examples/jsm/loaders/GLTFLoader.js'
        import { DRACOLoader } from 'https://cdn.skypack.dev/three@0.133.0/examples/jsm/loaders/DRACOLoader.js'
        import { GUI } from 'https://cdn.skypack.dev/three@0.133.0/examples/jsm/libs/dat.gui.module'
    </script>

    <script src="js/controls/OrbitControls.js"></script>

    <script src="js/curves/NURBSCurve.js"></script>
    <script src="js/curves/NURBSUtils.js"></script>
    <script src="js/loaders/FBXLoader.js"></script>

    <script src="js/Detector.js"></script>
    <script src="js/libs/inflate.min.js"></script>
    <script src="js/libs/stats.min.js"></script>

    <script>
        if (!Detector.webgl) Detector.addGetWebGLMessage();

        var container, stats, controls;
        var camera, scene, renderer, light;
        var sky, sunSphere;
        var fbx = window.location.search.substr(1).split('=')[1] + '.fbx';

        init();
        animate();

        function init() {


            container = document.createElement('div');
            document.body.appendChild(container);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            //cria um ambiente de luz mais natural
            ambientLight = new THREE.AmbientLight(0xffffff, 0.2)
            scene.add(ambientLight);

            light = new THREE.PointLight(0xffffff, 0.8, 18);
            light.position.set(-3, 6, -3);
            light.castShadow = true;
            light.shadow.camera.near = 0.1;
            light.shadow.camera.far = 25;
            scene.add(light);
            
            /*//cria um ambiente de luz mais natural, iluminação global
            scene.add(new THREE.AmbientLight(0xCDCDCD, .3));

            //Luz é emitida em um único ponto para todas as direções 
            var light = new THREE.PointLight(0x696969, .6);
            light.position.set(-600,600,800);
            scene.add(light);*/

            /*var hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444);
            hemisphereLight.position.set(0, 1, 0);
            scene.add(hemisphereLight);

            var directionalLight = new THREE.DirectionalLight(0xffffff, .5);
            directionalLight.position.set(0, 4, 4);
            scene.add(directionalLight);*/animate

            /*spotLight = new THREE.SpotLight(0xffffff, 1);
            spotLight.name = 'Spot Light';
            spotLight.angle = Math.PI / 5;
            spotLight.penumbra = 0.3;
            spotLight.position.set(10, 10, 5);
            spotLight.castShadow = true;
            spotLight.shadow.camera.near = 8;
            spotLight.shadow.camera.far = 30;
            spotLight.shadow.mapSize.width = 1024;
            spotLight.shadow.mapSize.height = 1024;
            scene.add(spotLight);

            scene.add(new THREE.CameraHelper(spotLight.shadow.camera));

            dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.name = 'Dir. Light';
            //dirLight.position.set(0, 10, 0);
            dirLight.position.set(20, 10, 10);
            dirLight.castShadow = true;
            dirLight.shadow.camera.near = 1;
            dirLight.shadow.camera.far = 10;
            dirLight.shadow.camera.right = 15;
            dirLight.shadow.camera.left = - 15;
            dirLight.shadow.camera.top = 15;
            dirLight.shadow.camera.bottom = - 15;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            scene.add(dirLight);

            scene.add(new THREE.CameraHelper(dirLight.shadow.camera));*/

            /*//eixos (para ajudar na orientação)
            axesHelper = new THREE.AxesHelper( 500 );
            scene.add( axesHelper ); */

            controls = new THREE.OrbitControls(camera);
            controls.addEventListener('change', render);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.enableZoom = true;
            //controls.minDistance = 200;
            //controls.maxDistance = 1000;

            //Angulo polar, não permite que tenha uma visão com (Y) negativo
            controls.minPolarAngle = -1;
            controls.maxPolarAngle = Math.PI * 0.55;

            //loadSkyBox();

            var geometry = new THREE.SphereGeometry(150, 60, 40);
            geometry.scale(- 1, 1, 1);



            var material = new THREE.MeshBasicMaterial({
                //map: new THREE.TextureLoader().load('images/BGCompleto_360.jpg')
                map: new THREE.TextureLoader().load('images/BGCompleto_360.jpg')
            });

            mesh = new THREE.Mesh(geometry, material);
            mesh.position.y += 5;
            scene.add(mesh);

            //Código comentado pois foi retirado o piso geométrico
            gt = new THREE.TextureLoader().load('images/Floor-Stone-Portuguesa.jpg');
            gg = new THREE.PlaneGeometry(800, 800);
            gm = new THREE.MeshBasicMaterial({ color: 0xffffff, map: gt });

            ground = new THREE.Mesh(gg, gm);
            ground.rotation.x = - Math.PI / 2;
            ground.material.map.repeat.set(100, 100);
            ground.material.map.wrapS = ground.material.map.wrapT = THREE.RepeatWrapping;
            ground.material.map.encoding = THREE.sRGBEncoding;
            ground.receiveShadow = true;

            //scene.add(ground);

            var loader = new THREE.FBXLoader();
            loader.load('84003.fbx', function (object) {
                offset = 1.25;

                object.scale.set(0.1, 0.1, 0.1)

                //obter centro do objeto
                const boundingBox = new THREE.Box3().setFromObject(object);
                const middle = new THREE.Vector3();
                const size = new THREE.Vector3();
                boundingBox.getCenter(middle);
                console.log("center", middle);
                boundingBox.getSize(size);
                console.log("size", size);

                //adicionar objecto
                //object.position.y -= 18;
                object.position.y -= middle.getComponent(1);
                ground.position.y -= middle.getComponent(1);

                //add objecto z from position camera
                //object.position.z -= 10;
                object.position.z = middle.getComponent(2);

                scene.add(object);

                const fov = camera.fov * (Math.PI / 280);
                const fovh = 2 * Math.atan(Math.tan(fov / 2) * camera.aspect);
                let dx = size.z / 2 + Math.abs(size.x / 2 / Math.tan(fovh / 2));
                let dy = size.z / 2 + Math.abs(size.y / 2 / Math.tan(fov / 2));
                let cameraZ = Math.max(dx, dy);

                // offset the camera, if desired (to avoid filling the whole canvas)
                if (offset !== undefined && offset !== 0) cameraZ *= offset;

                camera.position.set(0, 0, cameraZ);

                // set the far plane of the camera so that it easily encompasses the whole object
                const minZ = boundingBox.min.z;
                const cameraToFarEdge = (minZ < 0) ? -minZ + cameraZ : cameraZ - minZ;

                //camera.far = cameraToFarEdge * 3;
                camera.updateProjectionMatrix();

                if (controls !== undefined) {
                    // set camera to rotate around the center
                    controls.target = new THREE.Vector3(0, 0, 0);

                    // prevent camera from zooming out far enough to create far plane cutoff
                    controls.maxDistance = cameraToFarEdge * 2;
                }


            }, (ev) => {
                console.log(ev);
            }, (e) => {
                console.log(e);
            });

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMapEnabled = true;
            renderer.shadowMap.type = THREE.BasicShadowMap;
            renderer.shadowMapSoft = false;
            document.body.appendChild(renderer.domElement);
            //container.appendChild(renderer.domElement);
            


        }

        /*function loadSkyBox() {
            // Load the skybox images and create list of materials
            var materials = [
                createMaterial('images/skyX55+x.png'), // right
                createMaterial('images/skyX55-x.png'), // left
                createMaterial('images/skyX55+y.png'), // top
                createMaterial('images/skyX55-y.png'), // bottom
                createMaterial('images/skyX55+z.png'), // back
                createMaterial('images/skyX55-z.png') // front
            ];

            // Create a large cube
            var mesh = new THREE.Mesh(new THREE.BoxGeometry(1500, 1500, 1500, 1, 1, 1), new THREE.MeshFaceMaterial(materials));

            scene.add(mesh);
        }*/

        function initShadowMapViewers() {

            dirLightShadowMapViewer = new ShadowMapViewer(dirLight);
            spotLightShadowMapViewer = new ShadowMapViewer(spotLight);
            resizeShadowMapViewers();

        }

        function createMaterial(path) {
            var texture = THREE.ImageUtils.loadTexture(path);
            var material = new THREE.MeshBasicMaterial({ map: texture, overdraw: 0.5, side: THREE.BackSide });

            return material;
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            render();
        }
        function render() {
            renderer.render(scene, camera);
            resizeShadowMapViewers();
        }
    </script>

</body>

</html>